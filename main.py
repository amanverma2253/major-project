import numpy as np
import matplotlib.pyplot as plt
from sklearn.utils.multiclass import unique_labels
# Logistic map generator
def logistic_map(x, r):
    return r * x * (1 - x)  # Logistic map function

# Chebyshev map generator
def chebyshev_map(x, a):
    return a * x - x**3  # Chebyshev map function used for training the model

# Modulation using logistic map
def logistic_modulation(signal, data):
    modulated_signal = signal * data  # Modulate signal with data
    return modulated_signal

# Demodulation using logistic map
def logistic_demodulation(modulated_signal, chaotic_signal):
    recovered_signal = modulated_signal / chaotic_signal  # Demodulate the signal by dividing by chaotic signal
    return recovered_signal

# Modulation using Chebyshev map
def chebyshev_modulation(signal, data):
    modulated_signal = signal * data  # Modulate signal with data
    return modulated_signal

# Demodulation using a threshold
def chebyshev_demodulation(modulated_signal, threshold):
    recovered_signal = np.where(modulated_signal > threshold, 1, 0)  # Threshold-based demodulation
    return recovered_signal

# User input for data
user_input = input("Enter input signal: ")
# Convert input to NumPy array of integers
input_data = np.array([int(bit) for bit in user_input])

# Generating a chaotic signal using logistic map with 1000 samples
n_samples = 100
chaotic_signal_logistic = np.zeros(n_samples)
r = 3.9  # Logistic map parameter
x_logistic = 0.5  # Initial value for logistic map
for i in range(n_samples):
    chaotic_signal_logistic[i] = x_logistic
    x_logistic = logistic_map(x_logistic, r)

# Generating a chaotic signal using Chebyshev map with 1000 samples
chaotic_signal_chebyshev = np.zeros(n_samples)


a = 2.8  # Chebyshev map parameter
x_chebyshev = 0.5  # Initial value for Chebyshev map
for i in range(n_samples):
    chaotic_signal_chebyshev[i] = x_chebyshev
    x_chebyshev = chebyshev_map(x_chebyshev, a)

# Repeat or tile input_data to match the length of chaotic signal
tiled_input_data = np.tile(input_data, n_samples // len(input_data) + 1)[:n_samples]

# Modulate the chaotic signal generated by logistic map with the input data
modulated_signal_logistic = logistic_modulation(chaotic_signal_logistic, tiled_input_data)

# Demodulate the modulated signal obtained using logistic map
recovered_signal_logistic = np.round(logistic_demodulation(modulated_signal_logistic, chaotic_signal_logistic))
recovered_signal_logistic = recovered_signal_logistic.astype(int)  # Convert to integers

# Modulate the chaotic signal generated by Chebyshev map with the input data
modulated_signal_chebyshev = np.abs(chebyshev_modulation(chaotic_signal_chebyshev, tiled_input_data))

# Demodulate the modulated signal obtained using Chebyshev map
recovered_signal_chebyshev = chebyshev_demodulation(modulated_signal_chebyshev, threshold=0)

# Print the original input data and the recovered signals
print(chaotic_signal_logistic)
print(chaotic_signal_chebyshev)
print("Input Data: ", input_data)
print("Recovered Signal (Logistic Map): ", recovered_signal_logistic[:len(input_data)])
print("Recovered Signal (Chebyshev Map):", recovered_signal_chebyshev[:len(input_data)])





# # Convert the recovered signals to integers (if they are not already)
# recovered_signal_logistic = recovered_signal_logistic.astype(int)
# recovered_signal_chebyshev = recovered_signal_chebyshev.astype(int)

# # Create confusion matrices
# conf_matrix_logistic = confusion_matrix(input_data, recovered_signal_logistic[:len(input_data)])
# conf_matrix_chebyshev = confusion_matrix(input_data, recovered_signal_chebyshev[:len(input_data)])

# # Calculate accuracy
# accuracy_logistic = accuracy_score(input_data, recovered_signal_logistic[:len(input_data)])
# accuracy_chebyshev = accuracy_score(input_data, recovered_signal_chebyshev[:len(input_data)])

# # Print confusion matrices and accuracy
# print("\nConfusion Matrix (Logistic Map):\n", conf_matrix_logistic)
# print("\nAccuracy (Logistic Map):", accuracy_logistic)

# print("\nConfusion Matrix (Chebyshev Map):\n", conf_matrix_chebyshev)
# print("\nAccuracy (Chebyshev Map):", accuracy_chebyshev)

# # Plot confusion matrices
# class_names = unique_labels(input_data, recovered_signal_logistic[:len(input_data)])
# fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# plot_confusion_matrix(conf_matrix_logistic, classes=class_names, title='Confusion Matrix (Logistic Map)', ax=axes[0])
# plot_confusion_matrix(conf_matrix_chebyshev, classes=class_names, title='Confusion Matrix (Chebyshev Map)', ax=axes[1])

# plt.show()

import time

# Function to measure encryption time
def measure_encryption_time(modulation_function, chaotic_signal, input_data):
    start_time = time.time()
    modulated_signal = modulation_function(chaotic_signal, input_data)
    elapsed_time = time.time() - start_time
    return modulated_signal, elapsed_time

# List to store input lengths and corresponding encryption times
input_lengths = []
encryption_times_logistic = []
encryption_times_chebyshev = []

# Vary the input length and measure encryption time
for input_length in range(10, 501, 10):  # You can adjust the range based on your needs
    input_data = np.random.randint(2, size=input_length)  # Generate random input data
    tiled_input_data = np.tile(input_data, n_samples // len(input_data) + 1)[:n_samples]

    # Measure encryption time for Logistic Map
    _, time_logistic = measure_encryption_time(logistic_modulation, chaotic_signal_logistic, tiled_input_data)
    encryption_times_logistic.append(time_logistic)

    # Measure encryption time for Chebyshev Map
    _, time_chebyshev = measure_encryption_time(chebyshev_modulation, chaotic_signal_chebyshev, tiled_input_data)
    encryption_times_chebyshev.append(time_chebyshev)

    input_lengths.append(input_length)

# Plotting the results
plt.plot(input_lengths, encryption_times_logistic, label='Logistic Map')
plt.plot(input_lengths, encryption_times_chebyshev, label='Chebyshev Map')
plt.xlabel('Input Length')
plt.ylabel('Encryption Time (seconds)')
plt.title('Input vs Encryption Time')
plt.legend()
plt.show()



# Assuming you have a function like this
def encrypt_data(data):
    start_time = time.time()
    # Perform encryption here
    encrypted_data = data  # Replace this with your encryption logic
    end_time = time.time()
    encryption_time = end_time - start_time
    return encrypted_data, encryption_time

# Generate some sample data
data_sizes = range(100, 1000, 100)
encryption_times = []

for data_size in data_sizes:
    data = np.random.rand(data_size)
    _, encryption_time = encrypt_data(data)
    encryption_times.append(encryption_time)

# Now plot the data size vs encryption time
plt.figure(figsize=(10, 6))
plt.plot(data_sizes, encryption_times, marker='o')
plt.title('Data Size vs Encryption Time')
plt.xlabel('Data Size')
plt.ylabel('Encryption Time (seconds)')
plt.grid(True)
plt.show()
