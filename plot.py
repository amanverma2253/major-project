import numpy as np
import matplotlib.pyplot as plt
import timeit
from prettytable import PrettyTable
# Logistic map generator


def logistic_map(x, r):
    start_time = timeit.default_timer()
    return r * x * (1 - x)  # Logistic map function
    end_time = timeit.default_timer()
    print(f"Logistic_map execution time: {(end_time - start_time) * 1000} ms")

# Chebyshev map generator


def chebyshev_map(x, a):
    start_time = timeit.default_timer()
    return a * x - x**3  # Chebyshev map function used for training the model
    end_time = timeit.default_timer()
    print(f"Chebyshev_map execution time: {(end_time - start_time) * 1000} ms")

# Modulation using logistic map


def logistic_modulation(signal, data):
    start_time = timeit.default_timer()
    modulated_signal = signal * data  # Modulate signal with data
    end_time = timeit.default_timer()
    print(
        f"Logistic_modulation execution time: {(end_time - start_time) * 1000} ms")
    return modulated_signal

# Demodulation using logistic map


def logistic_demodulation(modulated_signal, chaotic_signal):
    start_time = timeit.default_timer()
    # Demodulate the signal by dividing by chaotic signal
    recovered_signal = modulated_signal / chaotic_signal
    end_time = timeit.default_timer()
    print(
        f":Logistic_demodulation execution time: {(end_time - start_time) * 1000} ms")
    return recovered_signal

# Modulation using Chebyshev map


def chebyshev_modulation(signal, data):
    start_time = timeit.default_timer()
    modulated_signal = signal * data  # Modulate signal with data
    end_time = timeit.default_timer()
    print(
        f"Chebyshev_modulation execution time: {(end_time - start_time) * 1000} ms")
    return modulated_signal

# Demodulation using a threshold


def chebyshev_demodulation(modulated_signal, threshold):
    start_time = timeit.default_timer()
    # Threshold-based demodulation
    recovered_signal = np.where(modulated_signal > threshold, 1, 0)
    end_time = timeit.default_timer()
    print(
        f"chebyshev_demodulation execution time: {(end_time - start_time) * 1000} ms")
    return recovered_signal

# # Example integer input data (replace with your data)
# input_data = np.array([1, 0, 1, 1, 0, 1, 0, 0, 1, 0])  # Example integer data


# User input for data
user_input = input("Enter binary data (0s and 1s),  ")
# Convert input to NumPy array of integers
input_data = np.array([int(bit) for bit in user_input])

# Generating a chaotic signal using logistic map with 1000 samples
n_samples = 1000
chaotic_signal_logistic = np.zeros(n_samples)
r = 3.9  # Logistic map parameter
x_logistic = 0.5  # Initial value for logistic map
for i in range(n_samples):
    chaotic_signal_logistic[i] = x_logistic
    x_logistic = logistic_map(x_logistic, r)

# Generating a chaotic signal using Chebyshev map with 1000 samples
chaotic_signal_chebyshev = np.zeros(n_samples)


a = 2.8  # Chebyshev map parameter
x_chebyshev = 0.5  # Initial value for Chebyshev map
for i in range(n_samples):
    chaotic_signal_chebyshev[i] = x_chebyshev
    x_chebyshev = chebyshev_map(x_chebyshev, a)

# Repeat or tile input_data to match the length of chaotic signal
tiled_input_data = np.tile(input_data, n_samples //
                           len(input_data) + 1)[:n_samples]

# Modulate the chaotic signal generated by logistic map with the input data
modulated_signal_logistic = logistic_modulation(
    chaotic_signal_logistic, tiled_input_data)

# Demodulate the modulated signal obtained using logistic map
recovered_signal_logistic = np.round(logistic_demodulation(
    modulated_signal_logistic, chaotic_signal_logistic))
recovered_signal_logistic = recovered_signal_logistic.astype(
    int)  # Convert to integers

# Modulate the chaotic signal generated by Chebyshev map with the input data
modulated_signal_chebyshev = np.abs(chebyshev_modulation(
    chaotic_signal_chebyshev, tiled_input_data))

# Demodulate the modulated signal obtained using Chebyshev map
recovered_signal_chebyshev = chebyshev_demodulation(
    modulated_signal_chebyshev, threshold=0)

# Print the original input data and the recovered signals
print(chaotic_signal_logistic)
print(chaotic_signal_chebyshev)
print("Input Data: ", input_data)
print("Recovered Signal (Logistic Map): ",
      recovered_signal_logistic[:len(input_data)])
print("Recovered Signal (Chebyshev Map):",
      recovered_signal_chebyshev[:len(input_data)])

# Create subplots for each signal
plt.figure(figsize=(10, 10))

# Logistic map chaotic signal
plt.subplot(321)
plt.plot(chaotic_signal_logistic)
plt.xlabel("Time")
plt.ylabel("Logistic Map Chaotic Signal")

# Chebyshev map chaotic signal
plt.subplot(322)
plt.plot(chaotic_signal_chebyshev)
plt.xlabel("Time")
plt.ylabel("Chebyshev Map Chaotic Signal")

# Modulated signal (Logistic Map)
plt.subplot(323)
plt.plot(modulated_signal_logistic)
plt.xlabel("Time")
plt.ylabel("Modulated Signal (Logistic Map)")

# Demodulated signal (Logistic Map)
plt.subplot(324)
plt.plot(recovered_signal_logistic)
plt.xlabel("Time")
plt.ylabel("Demodulated Signal (Logistic Map)")

# Modulated signal (Chebyshev Map)
plt.subplot(325)
plt.plot(modulated_signal_chebyshev)
plt.xlabel("Time")
plt.ylabel("Modulated Signal (Chebyshev Map)")

# Demodulated signal (Chebyshev Map)
plt.subplot(326)
plt.plot(recovered_signal_chebyshev)
plt.xlabel("Time")
plt.ylabel("Demodulated Signal (Chebyshev Map)")

# Adjust layout and show the plot
plt.tight_layout()
plt.show()